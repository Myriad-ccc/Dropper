using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Media;
using System.Windows.Forms;

namespace Dropper
{
    public class Block
    {
        public RectangleF Bounds { get; set; } = new RectangleF(PointF.Empty, new SizeF(64, 64));
        public PointF Location => Bounds.Location;
        public SizeF Size => Bounds.Size;

        public bool Active { get; set; } = false;
        public bool MouseDragging { get; set; }
        public Rectangle UserBounds { get; set; }

        public Color ActiveColor { get; set; } = QOL.RGB(50);
        public Color InactiveColor { get; set; } = QOL.RGB(50);
        public Color ActiveBorderColor { get; set; } = QOL.RGB(163, 42, 42);
        public Color InactiveBorderColor { get; set; } = QOL.RGB(25);

        public float BorderWidth => (float)Math.Pow(W, 1f / 6f);

        public float Weight { get; set; } = 100.0f;
        public float OriginalWeight { get; set; }
        public static Point StartPoint { get; set; }
        public PointF MagneticCore { get; set; }

        public float VX { get; set; } = 0.0f;
        public float VY { get; set; } = 0.0f;

        public float Area => W * H;
        public float TerminalVelocity => (float)Math.Pow(Area * Math.Abs(Weight), 1f / 1.8f);

        public float Restituion { get; set; } = 0.70f;

        public bool CanBounce { get; set; } = true;
        public List<Crack> Cracks = new List<Crack>();

        public float X => Location.X;
        public float Y => Location.Y;
        public float W => Size.Width;
        public float H => Size.Height;
        public float Left => Bounds.Left;
        public float Right => Bounds.Right;
        public float Top => Bounds.Top;
        public float Bottom => Bounds.Bottom;

        public Block() { }

        public enum GravityMode { Linear, Dynamic, Magnetic, None }
        public GravityMode Gravity { get; set; } = GravityMode.Dynamic;

        public float VTX { get; set; }
        public float VTY { get; set; }
        public void Constrain(int GX = 0, int GY = 0)
        {
            if (UserBounds == Rectangle.Empty) return;
            float nx = X;
            float ny = Y;
            bool bouncingX = false;
            bool bouncingY = false;
            float deltaTime = QOL.GlobalTimerUpdateRate / 1000f;
            float gc = Dropper.Gravity.GravitationalConstant;

            if (Left <= UserBounds.Left)
            {
                if (Math.Abs(VX) >= Math.Abs(TerminalVelocity) && Weight != 0)
                    Cracks.Add(new Crack(this));

                nx = UserBounds.Left;
                VTX = (GX * Weight < 0) ? (Math.Abs(Weight) * deltaTime * gc) : 0;

                if (CanBounce && VX < -VTX && !bouncingX)
                {
                    VX = -VX * Restituion;
                    bouncingX = true;
                }
                else
                    ResetVX();
            }

            if (Right >= UserBounds.Right)
            {
                if (Math.Abs(VX) >= Math.Abs(TerminalVelocity) && Weight != 0)
                    Cracks.Add(new Crack(this));

                nx = UserBounds.Right - W;
                VTX = (GX * Weight > 0) ? (Math.Abs(Weight) * deltaTime * gc) : 0;

                if (CanBounce && !bouncingX && VX > VTX)
                    VX = -VX * Restituion;
                else
                    ResetVX();
            }

            if (Top <= UserBounds.Top)
            {
                if (Math.Abs(VY) >= Math.Abs(TerminalVelocity) && Weight != 0)
                    Cracks.Add(new Crack(this));

                ny = UserBounds.Top;
                VTY = (GY * Weight < 0) ? (Math.Abs(Weight) * deltaTime * gc) : 0;

                if (CanBounce && !bouncingY && VY < -VTY)
                {
                    VY = -VY * Restituion;
                    bouncingY = true;
                }
                else
                    ResetVY();
            }

            if (Bottom >= UserBounds.Bottom)
            {
                if (Math.Abs(VY) == Math.Abs(TerminalVelocity) && Weight != 0)
                    Cracks.Add(new Crack(this));

                ny = UserBounds.Bottom - H;
                VTY = (GY * Weight > 0) ? (Math.Abs(Weight) * deltaTime * gc) : 0;

                if (CanBounce && !bouncingY && VY > VTY)
                    VY = -VY * Restituion;
                else
                    ResetVY();
            }

            Bounds = new RectangleF(new PointF(nx, ny), Size);
        }

        public void ResetVX() => VX = 0;
        public void ResetVY() => VY = 0;
        public void ResetVelocity()
        {
            ResetVX();
            ResetVY();
        }

        public void DoubleSize()
        {
            float nw = W * 2f;
            float nh = H * 2f;
            float nx = X - W / 2f;
            float ny = Y - H / 2f;

            Bounds = new RectangleF(new PointF(nx, ny), new SizeF(nw, nh));
        }

        public void HalveSize()
        {
            float nw = W / 2f;
            float nh = H / 2f;
            float nx = X + nw / 2f;
            float ny = Y + nh / 2f;

            Bounds = new RectangleF(new PointF(nx, ny), new SizeF(nw, nh));
        }

        public Block Copy()
        {
            return new Block()
            {
                Bounds = this.Bounds,
                Active = this.Active,
                MouseDragging = this.MouseDragging,
                UserBounds = this.UserBounds,
                ActiveColor = this.ActiveColor,
                InactiveColor = this.InactiveColor,
                ActiveBorderColor = this.ActiveBorderColor,
                InactiveBorderColor = this.InactiveBorderColor,
                Weight = this.Weight,
                OriginalWeight = this.OriginalWeight,
                MagneticCore = this.MagneticCore,
                VX = this.VX,
                VY = this.VY,
                Restituion = this.Restituion,
                CanBounce = this.CanBounce,
                Cracks = new List<Crack>(this.Cracks),
                Gravity = this.Gravity,
            };
        }

        public static Block Clone(Block source)
        {
            if (source == null) return null;
            return source.Copy();
        }
    }

    public class Crack
    {
        private static readonly Random random = new Random();
        private readonly Bitmap CrackBitMap = Properties.Resources.Crack;

        private float StartX { get; set; }
        private float StartY { get; set; }

        private float EndX { get; set; }
        private float EndY { get; set; }

        private float DX => EndX - StartX;
        private float DY => EndY - StartY;

        private float Angle => (float)Math.Atan2(DY, DX) * (180.0f / (float)Math.PI);
        private float Length => (float)Math.Sqrt(DX * DX + DY * DY);

        private float ScaleX => Length / CrackBitMap.Width;
        private float ScaleY { get; set; }

        private readonly SoundPlayer VineBoom = new SoundPlayer(Properties.Resources.VineBoom);

        public Crack(Block block)
        {
            if (block.Cracks.Count == 3) return;

            //if (block.Active)
            //    VineBoom.Play();

            StartX = (float)(block.W * random.NextDouble());
            StartY = (float)(block.H * random.NextDouble());
            EndX = (float)(block.W * random.NextDouble());
            EndY = (float)(block.H * random.NextDouble());

            while (Math.Abs(StartX - EndX) < block.W / 10 || Math.Abs(StartY - EndY) < block.H / 10)
            {
                EndX = (float)(block.W * random.NextDouble());
                EndY = (float)(block.H * random.NextDouble());
            }
            ScaleY = (float)(random.NextDouble() + 2);
        }

        public static void DrawAll(Graphics g, Block block)
        {
            var crackRegion = block.Bounds;
            crackRegion.Inflate(-2, -2);
            g.SetClip(crackRegion);

            var blockState = g.Save();

            g.TranslateTransform(block.Left, block.Top);

            for (int i = 0; i < block.Cracks.Count; i++)
                block.Cracks[i].Draw(g);

            g.Restore(blockState);

            g.ResetClip();
        }

        private void Draw(Graphics g)
        {
            if (Length == 0) return;

            var crackState = g.Save();

            g.TranslateTransform(StartX, StartY);

            g.RotateTransform(Angle);
            g.ScaleTransform(ScaleX, ScaleY);

            g.DrawImage(CrackBitMap, 0, -CrackBitMap.Height / 2f);

            g.Restore(crackState);
        }
    }

    public class Blocks
    {
        private readonly Random random = new Random();

        public static List<Block> Stack { get; set; } = new List<Block>();
        public Block Target { get; set; }

        public event Action<Block> ChangeFocus;
        public event Action<Block> ConfigureBlock;
        public event Action Redraw;

        public void Add(Block @new = null)
        {
            Block block = @new ?? new Block();
            Stack.Add(block);
            ConfigureBlock.Invoke(block);

            if (Stack.Count == 1)
            {
                block.Active = true;
                ChangeFocus.Invoke(block);
            }
        }

        public void Remove(bool RandomRefocus = false)
        {
            Stack.Remove(Target);
            Target = null;
            var refocused =
                RandomRefocus
                ? (Stack.Count > 0 ? Stack[random.Next(Stack.Count)] : null)
                : (Stack.Count >= 1 ? Stack[Stack.Count - 1] : null);
            ChangeFocus.Invoke(refocused);
        }

        public void Split(Block block)
        {
            var left = Block.Clone(block);
            var right = Block.Clone(block);

            left.Cracks.Clear();
            right.Cracks.Clear();

            if (block.Active)
            {
                int randomBool = random.Next(0, 2);
                left.Active = randomBool == 0;
                right.Active = !left.Active;
                ChangeFocus.Invoke(left.Active ? left : right);
            }
            else left.Active = right.Active = false;

            int index = Stack.IndexOf(block);
            Stack.Remove(block);

            left.Bounds = new RectangleF(
                new PointF(
                    left.Left,
                    left.Top),
                new SizeF(
                    left.W / 2,
                    left.H));
            left.Weight /= 2;
            left.VX /= 2;
            left.VY /= 2;

            right.Bounds = new RectangleF(
                new PointF(
                    right.Left + right.W / 2,
                    right.Top),
                new SizeF(
                    right.W / 2,
                    right.H));
            right.Weight /= 2;
            right.VX /= 2;
            right.VY /= 2;

            Stack.Insert(index, left);
            Stack.Insert(index, right);

            Redraw.Invoke();
        }
    }
}
using System;
using System.Drawing;
using System.Windows.Forms;

namespace Dropper
{
    public class Card : CustomButton
    {
        public bool On { get; set; } = false;
        public static int CardWidth { get; set; } = 32;
        public static int CardHeight { get; set; } = 32;

        public static Card[,] deck;
        public int DeckRow { get; set; }
        public int DeckCol { get; set; }

        private static readonly Color defaultBG = QOL.RGB(35);

        public Card(int deckRow, int deckCol)
        {
            DeckRow = deckRow;
            DeckCol = deckCol;

            BackColor = defaultBG;
            FlatStyle = FlatStyle.Popup;
            Size = new Size(CardWidth, CardHeight);
            TabStop = false;
            UseCompatibleTextRendering = true;
            TextAlign = ContentAlignment.TopCenter;
            Font = new Font(QOL.VCROSDMONO, CardWidth / 2);

            MouseClick += (s, ev) => SetActive();
        }

        public void Toggle()
        {
            On = !On;
            BackColor = On ? Color.CornflowerBlue : defaultBG;
        }

        public static Action<int, int> Activated;
        public void SetActive()
        {
            foreach (Card card in deck)
                if (card.On)
                    card.Toggle();
            Toggle();
            Activated.Invoke(DeckRow, DeckCol);
        }

        public static Card GetActive()
        {
            foreach (Card card in deck)
                if (card.On)
                    return card;
            return null;
        }
    }
}
using System.Windows.Forms;

namespace Dropper
{
    public class ClickFilter : IMessageFilter
    {
        public Control TargetControl;

        public ClickFilter(Control targetControl) => TargetControl = targetControl;

        public bool PreFilterMessage(ref Message m)
        {
            const int LBM_code = 0x0201;

            if (m.Msg == LBM_code)
            {
                Control clickedControl = Control.FromHandle(m.HWnd);

                if (clickedControl != TargetControl && !TargetControl.Contains(clickedControl))
                    TargetControl.FindForm().Focus();
            }
            return false;
        }
    }
}
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;

namespace Dropper
{
    public class ControlBar : CustomPanel
    {
        private readonly CustomButton closingButton;
        private readonly CustomButton minimizeButton;

        private readonly List<ControlledPanel> Controllers = new List<ControlledPanel>();
        private readonly LerpButton PanelTrigger;
        private readonly ControlledPanel PanelController;

        public event Action<bool> ShowToolBar;

        public ControlBar(ToolBarPanel toolBar, CustomPanel panelOptions)
        {
            Drag();
            BackColor = QOL.RGB(35);

            closingButton = new CustomButton()
            {
                TabStop = false,
                FlatStyle = FlatStyle.Flat,
                TextAlign = ContentAlignment.MiddleCenter,
                BackColor = QOL.RGB(20),
                ForeColor = Color.FromArgb(255, 163, 42, 42),
                Font = new Font(QOL.VCROSDMONO, 20f),
                Text = "✖",
            };
            closingButton.MouseClick += (s, ev) => FindForm()?.Close();
            Controls.Add(closingButton);

            minimizeButton = new CustomButton()
            {
                TabStop = false,
                FlatStyle = FlatStyle.Flat,
                TextAlign = ContentAlignment.MiddleCenter,
                BackColor = QOL.RGB(20),
                ForeColor = Color.FromArgb(255, 42, 163, 150),
                Font = new Font(QOL.VCROSDMONO, 20f),
                Text = "―",
            };
            minimizeButton.MouseClick += (s, ev) => FindForm().WindowState = FormWindowState.Minimized;
            Controls.Add(minimizeButton);

            PanelTrigger = new LerpButton(0.00005f, QOL.RandomColor())
            {
                BackColor = QOL.RandomColor(),
                Font = new Font(QOL.VCROSDMONO, 20f, FontStyle.Underline),
                Text = "Paneling",
                Size = new Size(140, 40)
            };
            Controls.Add(PanelTrigger);

            string[] names = toolBar.Values
                        .Select(x =>
                             x.GetType().Name
                                .Substring(0, x.GetType().Name.Skip(1).TakeWhile(c => !char.IsUpper(c)).Count() + 1))
                        .ToArray();
            names[1] = "Slider";
            PanelController = new ControlledPanel(PanelTrigger, panelOptions, new LerpButton[names.Length], names);
            Controllers.Add(PanelController);
            PanelController.Showing += (s, ev) =>
            {
                var showingController = s as ControlledPanel;

                foreach (var controller in Controllers)
                    if (controller != showingController)
                        PanelController.Hide();
            };

            var PanelButtons = panelOptions.Controls.OfType<LerpButton>().ToList();
            for (int i = 0; i < PanelButtons.Count; i++)
            {
                int b = i;
                var button = PanelButtons[b];
                button.MouseDown += (s, ev) =>
                {
                    if (ev.Button == MouseButtons.Left)
                    {
                        button.On = !button.On;
                        button.ForeColor = button.On ? Color.CornflowerBlue : Color.White;
                        toolBar.Values[b].Visible = button.On;
                        ShowToolBar?.Invoke(PanelButtons.Any(x => x.On));
                    }
                };
            }
        }

        protected override void OnSizeChanged(EventArgs e)
        {
            base.OnSizeChanged(e);

            closingButton.Size = new Size(ClientSize.Height, ClientSize.Height);
            closingButton.Location = new Point(ClientSize.Width - closingButton.Width);
            minimizeButton.Size = closingButton.Size;
            QOL.Align.Left(minimizeButton, closingButton, 4);
        }

        public void Drag()
        {
            bool MouseDragging = false;
            Point cursorPos = Cursor.Position;

            MouseDown += (s, ev) =>
            {
                if (ev.Button == MouseButtons.Left)
                {
                    MouseDragging = true;
                    cursorPos = Cursor.Position;
                }
            };

            MouseUp += (s, ev) => MouseDragging = false;

            MouseMove += (s, ev) =>
            {
                if (MouseDragging)
                {
                    int deltaX = Cursor.Position.X - cursorPos.X;
                    int deltaY = Cursor.Position.Y - cursorPos.Y;

                    FindForm().Left += deltaX;
                    FindForm().Top += deltaY;

                    cursorPos = Cursor.Position;

                    Invalidate();
                }
            };
        }
    }
}
using System;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;

namespace Dropper
{
    public class ControlledPanel
    {
        public LerpButton Trigger { get; }
        public CustomPanel Options { get; }

        public event EventHandler Showing;

        private readonly Timer AnimationTimer = new Timer() { Interval = 10 };
        private int AnimationSpeed;
        private readonly int TargetHeight;
        private bool Expanding = false;

        public ControlledPanel(
            LerpButton trigger, CustomPanel options,
            LerpButton[] optionButtons, string[] names,
            int animationSpeed = 5
            )
        {
            Trigger = trigger;
            Options = options;
            AnimationSpeed = animationSpeed;
            TargetHeight = options.Height;

            options.Visible = false;
            options.Width = Trigger.Width;
            options.Height = 0;

            for (int i = 0; i < optionButtons.Length; i++)
            {
                var button = new LerpButton()
                {
                    TabStop = false,
                    FlatStyle = FlatStyle.Flat,
                    Size = new Size(Options.Width, TargetHeight / names.Length),
                    Location = new Point(0, i * (TargetHeight / names.Length)),
                    Font = new Font(QOL.VCROSDMONO, 16f),
                    Text = names[i],
                };
                Options.Controls.Add(button);
            }

            AnimationTimer.Tick += (s, ev) =>
            {
                if (Expanding)
                {
                    Options.Height += AnimationSpeed;
                    if (Options.Height >= TargetHeight)
                    {
                        Options.Height = TargetHeight;
                        AnimationTimer.Stop();
                    }
                }
                else
                {
                    Options.Height -= AnimationSpeed;
                    if (Options.Height <= 0)
                    {
                        Options.Height = 0;
                        Options.Visible = false;
                        AnimationTimer.Stop();
                        AnimationSpeed = Math.Min(++AnimationSpeed, 10);
                    }
                }
            };

            Trigger.Tag = Options;
            Trigger.MouseEnter += Show;
            Trigger.MouseLeave += CheckState;
            Options.MouseLeave += CheckState;
            foreach (Control control in Options.Controls.OfType<Button>())
                control.MouseLeave += CheckState;
        }

        public void Show(object sender, EventArgs e)
        {
            Showing?.Invoke(sender, EventArgs.Empty);

            Point triggerBottomLeft = Trigger.Parent.PointToScreen(new Point(Trigger.Left, Trigger.Bottom));
            Options.Location = Options.Parent.PointToClient(triggerBottomLeft);

            Options.Visible = true;
            Expanding = true;
            AnimationTimer.Start();
        }

        public void Hide()
        {
            if (!Options.Visible || Options.Height == 0)
                return;

            Expanding = false;
            AnimationTimer.Start();
        }

        private bool Hovering(Panel panel)
        {
            if (!panel.Visible)
                return false;

            if (panel.Bounds.Contains(panel.Parent.PointToClient(Cursor.Position)))
                return true;

            foreach (Button button in panel.Controls.OfType<Button>())
                if (button.Tag is Panel descendent)
                    if (Hovering(descendent))
                        return true;
            return false;
        }

        private void CheckState(object sender, EventArgs e)
        {
            if (Trigger.Parent == null)
                return;

            if (Trigger.Bounds.Contains(Trigger.Parent.PointToClient(Cursor.Position)))
                return;

            if (Hovering(Options))
                return;

            Hide();
        }
    }
}
using System.Windows.Forms;

namespace Dropper
{
    public class CustomButton : Button
    {
        public CustomButton()
        {
            DoubleBuffered = true;
            TabStop = false;
        }
        protected override bool ShowFocusCues => false;
        protected override bool ShowKeyboardCues => false;
    }
}
using System;
using System.Drawing;
using System.Windows.Forms;

namespace Dropper
{
    public class CustomPanel : Panel
    {
        public bool Draggable { get; set; } = false;
        public Rectangle ParentBounds { get; set; } = Rectangle.Empty; // intended to be used in tandem with the drag logic
        public bool Added { get; set; } = false;

        public CustomPanel()
        {
            DoubleBuffered = true;
            TabStop = false;
            SetStyle(
                ControlStyles.UserPaint |
                ControlStyles.AllPaintingInWmPaint |
                ControlStyles.OptimizedDoubleBuffer, true);
            UpdateStyles();
        }
        protected override bool ShowFocusCues => false;

        private bool Dragging;
        private Point CursorPosition;
        protected override void OnMouseDown(MouseEventArgs e)
        {
            base.OnMouseDown(e);

            if (!Draggable) return;
            CursorPosition = Cursor.Position;
            if (e.Button == MouseButtons.Right)
            {
                Dragging = true;
                CursorPosition = Cursor.Position;
            }
        }
        protected override void OnMouseUp(MouseEventArgs e)
        {
            base.OnMouseUp(e);

            if (!Draggable) return;
            Dragging = false;
        }
        protected override void OnMouseMove(MouseEventArgs e)
        {
            base.OnMouseMove(e);

            if (!Draggable) return;
            if (ParentBounds == Rectangle.Empty) return;

            if (Dragging)
            {
                int deltaX = Cursor.Position.X - CursorPosition.X;
                int deltaY = Cursor.Position.Y - CursorPosition.Y;

                int nx = Math.Max(ParentBounds.Left, Math.Min(Location.X + deltaX, ParentBounds.Right - Width));
                int ny = Math.Max(ParentBounds.Top, Math.Min(Location.Y + deltaY, ParentBounds.Bottom - Height));

                Bounds = new Rectangle(
                    new Point(
                        nx,
                        ny),
                    Size);

                CursorPosition = Cursor.Position;
                Invalidate();
            }
        }
    }
}
using System;
using System.Drawing;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Windows.Forms;

namespace Dropper
{
    public partial class Form1 : Form
    {
        private Blocks blocks;
        private Gravity gravity;

        private ControlBar controlBar;
        private ToolBarPanel toolBar;
        private GameArea gameArea;
        private Floor floor;

        private CustomPanel PanelOptions;

        public Form1() => InitializeComponent();

        private void Form1_Load(object sender, EventArgs e)
        {
            ConfigureForm();
            HoodooVoodooBlockMagic();

            blocks = new Blocks();
            blocks.Redraw += () => gameArea.Invalidate();
            blocks.ChangeFocus += block => ChangeFocusedBlock(block);
            blocks.ConfigureBlock += ConfigureBlock;

            gravity = new Gravity();
            gravity.Redraw += () => gameArea.Invalidate();
            gravity.SplitBlock += block => blocks.Split(block);

            toolBar = new ToolBarPanel(gravity);
            PanelOptions = new CustomPanel()
            {
                Height = 160,
                BackColor = QOL.RandomColor(),
            };
            controlBar = new ControlBar(toolBar, PanelOptions);
            gameArea = new GameArea();
            floor = new Floor();

            Controls.Add(PanelOptions);
            Controls.Add(toolBar);
            Controls.Add(gameArea);
            Controls.Add(controlBar);
            Controls.Add(floor);

            gameArea.Dock = DockStyle.Fill;

            controlBar.Height = 54;
            controlBar.Dock = DockStyle.Top;

            toolBar.Size = new Size(ClientSize.Width, 0);
            toolBar.Location = new Point(0, controlBar.Bottom);
            toolBar.Hide();

            floor.Height = 32;
            floor.Dock = DockStyle.Bottom;

            controlBar.ShowToolBar += show =>
            {
                var timer = new Timer { Interval = 10 };
                int target = show ? 98 : 0;

                foreach (var block in Blocks.Stack)
                    block.UserBounds = new Rectangle(
                        gameArea.Location.X,
                            gameArea.Location.Y + (show ? 44 : -54), // i have no earthly idea why the magic numbers are 44 and -54. i never will
                        gameArea.Width, // UPDATE!!: 54 is controlbar's width. 44 remains a complete mystery
                    gameArea.Height - (show ? 98 : 0)); //UPDATE 2: replacing -54 with -controlBar.Height breaks everything. i am mystified


                timer.Tick += (s, ev) =>
                {
                    int step = show ? 5 : -5;
                    toolBar.Height += step;
                    if (toolBar.Height >= target && show || toolBar.Height <= target && !show)
                    {
                        toolBar.Height = target;
                        timer.Stop();
                    }
                    toolBar.Visible = toolBar.Height > 0;
                };

                if (show) toolBar.Visible = true;
                timer.Start();
            };
            gameArea.FocusedBlockChanged += block => ChangeFocusedBlock(block);
            gameArea.SplitBlock += block => blocks.Split(block);

            blocks.Add();
            gravity.Start(Blocks.Stack);
            //KeyMovement();
        }

        private void ConfigureForm()
        {
            Text = "Dropper";
            FormBorderStyle = FormBorderStyle.None;
            Size = new Size(1024, 896);
            BackColor = QOL.RGB(20);
            KeyPreview = true;
            DoubleBuffered = true;
            CenterToScreen();

            FormClosing += (s, ev) => //might be leaving some timers running unintentionally
                Application.RemoveMessageFilter(toolBar.weightPanel.WeightDisplayFilter);
        }
        private void ChangeFocusedBlock(Block block)
        {
            if (block == blocks.Target)
                return;

            if (blocks.Target != null)
                blocks.Target.Active = false;
            blocks.Target = block;
            blocks.Target.Active = true;

            toolBar.SetTarget(block);
            gameArea.Invalidate();
        }
        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            if (keyData == Keys.Enter)
            {
                blocks.Add();
                return true;
            }
            return base.ProcessCmdKey(ref msg, keyData);
        }
        private void HoodooVoodooBlockMagic()
        {
            bool spaceDown = false;
            bool shiftDown = false;
            bool eventResolved = false;

            KeyDown += (s, ev) =>
            {
                if (eventResolved) return;

                if (ev.KeyCode == Keys.Space)
                {
                    eventResolved = true;
                    if (ev.Shift)
                    {
                        if (blocks.Target.W / 2 >= 4 && blocks.Target.H / 2 >= 4)
                            blocks.Target.HalveSize();
                    }
                    else
                        if (blocks.Target.W <= gameArea.Width / 2 && blocks.Target.H <= gameArea.Height / 2)
                        blocks.Target.DoubleSize();
                    gameArea.Invalidate();
                }
                if (ev.KeyCode == Keys.Back)
                {
                    if (toolBar.weightPanel.weightDisplay.ContainsFocus)
                        return;
                    blocks.Remove();
                    gameArea.Invalidate();
                }
            };

            KeyUp += (s, ev) =>
            {
                if (ev.KeyCode == Keys.Space)
                    eventResolved = false;
            };
        }

        private void ConfigureBlock(Block block)
        {
            block.OriginalWeight = block.Weight;
            block.UserBounds = gameArea.ClientRectangle;

            Block.StartPoint = new Point(
                (int)(gameArea.Width / 2 - block.W / 2),
                (int)(gameArea.ClientSize.Height - block.H));
            block.Bounds = new RectangleF(Block.StartPoint, block.Size);

            block.MagneticCore = new Point(
                (int)(gameArea.Width / 2 - block.W / 2),
                (int)(gameArea.Height / 2 - block.H / 2));
        }
    }
}
namespace Dropper
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.SuspendLayout();
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(122, 60);
            this.Name = "Form1";
            this.Text = "Form1";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.ResumeLayout(false);

        }

        #endregion
    }
}

using System;
using System.Drawing;
using System.Windows.Forms;

namespace Dropper
{
    public class ExpandedWeightMenu : CustomPanel
    {
        public event Action<float> WeightChanged;

        private bool built;
        private Block targetBlock;

        public void SetTarget(Block block)
        {
            targetBlock = block ?? throw new ArgumentNullException();
            if (!built)
            {
                Build();
                built = true;
            }
        }
        public ExpandedWeightMenu()
        {
            if (built)
                Paint += (s, ev) =>
                {
                    using (Pen borderPen = new Pen(QOL.RandomColor(), 1f))
                        ev.Graphics.DrawRectangle(borderPen, 0, 0, ClientSize.Width - 1, ClientSize.Height - 2);
                };
        }

        private void Build()
        {
            Visible = false;
            BackColor = Color.Transparent;

            Card[,] buttons = new Card[6, 3];
            Size = new Size(buttons.GetLength(0) * 24, buttons.GetLength(1) * 24);
            for (int r = 0; r < buttons.GetLength(0); r++)
            {
                for (int c = 0; c < buttons.GetLength(1); c++)
                {
                    int x = r;
                    int y = c;
                    var b = QOL.GenericControls.Button(null, "-", Color.Gray);
                    b.Location = new Point(x * 24, y * 24);

                    switch (y)
                    {
                        case 0:
                            switch (x)
                            {
                                case 0:
                                    b.Name = "squareWeight";
                                    b.Font = new Font(b.Font.FontFamily, 16f);
                                    b.ForeColor = Color.Crimson;
                                    b.Text = "2";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        if (Math.Abs(targetBlock.Weight) <= Math.Sqrt(float.MaxValue))
                                        {
                                            targetBlock.Weight = (float)Math.Pow(targetBlock.Weight, 2);
                                            WeightChanged.Invoke(targetBlock.Weight);
                                        }
                                    };
                                    break;
                                case 1:
                                    b.Name = "cubeWeight";
                                    b.Font = new Font(b.Font.FontFamily, 16f);
                                    b.ForeColor = Color.Salmon;
                                    b.Text = "3";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        if (Math.Abs(targetBlock.Weight) <= Math.Pow(float.MaxValue, 1.0f / 3.0f))
                                        {
                                            targetBlock.Weight = (float)Math.Pow(targetBlock.Weight, 3);
                                            WeightChanged.Invoke(targetBlock.Weight);
                                        }
                                    };
                                    break;
                                case 2:
                                    b.Name = "flipWeight";
                                    b.ForeColor = Color.Tomato;
                                    b.Text = "||";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        targetBlock.Weight = targetBlock.Weight * Math.Sign(-1);
                                        WeightChanged.Invoke(targetBlock.Weight);
                                    };
                                    break;
                                case 3:
                                    b.Name = "factorializeWeight";
                                    b.ForeColor = Color.PaleVioletRed;
                                    b.Text = "!";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        if (targetBlock.Weight == (int)targetBlock.Weight && targetBlock.Weight >= 0 && targetBlock.Weight <= 16)
                                        {
                                            targetBlock.Weight = QOL.Factorial((int)targetBlock.Weight);
                                            WeightChanged.Invoke(targetBlock.Weight);
                                        }
                                    };
                                    break;
                                case 4:
                                    b.Name = "clockIncrementingWeight";
                                    b.UseCompatibleTextRendering = true;
                                    b.Font = new Font(b.Font.FontFamily, 14f);
                                    b.ForeColor = Color.Beige;
                                    b.Text = "⏱️";
                                    bool on = false;
                                    var timer = new Timer() { Interval = 1000 };
                                    timer.Tick += (s, ev) =>
                                    {
                                        targetBlock.Weight = DateTime.Now.Second;
                                        WeightChanged.Invoke(targetBlock.Weight);
                                    };
                                    b.MouseClick += (s, ev) =>
                                    {
                                        on = !on;
                                        if (on)
                                        {
                                            b.ForeColor = Color.OrangeRed;
                                            timer.Start();
                                        }
                                        else
                                        {
                                            b.ForeColor = Color.Beige;
                                            timer.Stop();
                                        }
                                    };
                                    break;
                                case 5:

                                    break;
                                case 6:

                                    break;
                                case 7:

                                    break;
                                case 8:

                                    break;
                                case 9:

                                case 10:

                                    break;
                            }
                            break;
                        case 1:
                            switch (x)
                            {
                                case 0:
                                    b.Name = "squareRootWeight";
                                    b.ForeColor = Color.DarkSlateBlue;
                                    b.Text = "√";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        if (targetBlock.Weight > 0)
                                        {
                                            targetBlock.Weight = (float)Math.Sqrt(targetBlock.Weight);
                                            WeightChanged.Invoke(targetBlock.Weight);
                                        }
                                    };
                                    break;
                                case 1:
                                    b.Name = "cubeRootWeight";
                                    b.Font = new Font(b.Font.FontFamily, 16f);
                                    b.ForeColor = Color.Silver;
                                    b.Text = "∛";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        if (targetBlock.Weight > 0)
                                        {
                                            targetBlock.Weight = (float)Math.Pow(targetBlock.Weight, 1.0f / 3.0f);
                                            WeightChanged.Invoke(targetBlock.Weight);
                                        }
                                    };
                                    break;
                                case 2:
                                    b.Name = "piWeight";
                                    b.ForeColor = Color.CadetBlue;
                                    b.Text = "π";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        targetBlock.Weight = (float)Math.PI;
                                        WeightChanged.Invoke(targetBlock.Weight);
                                    };
                                    break;
                                case 3:
                                    b.Name = "reciprocateWeight";
                                    b.Font = new Font(b.Font.FontFamily, 16f);
                                    b.ForeColor = Color.BlueViolet;
                                    b.Text = "/";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        if (targetBlock.Weight != 0)
                                            targetBlock.Weight = 1 / targetBlock.Weight;
                                        WeightChanged.Invoke(targetBlock.Weight);
                                    };
                                    break;
                                case 4:
                                    b.Name = "accumulateWeight";
                                    b.ForeColor = Color.Gold;
                                    b.Text = "⌖";

                                    float secondsDragged = 0;
                                    float weightPerSecond = 0;
                                    int updateRate = 100;
                                    var timer = new Timer() { Interval = updateRate };
                                    timer.Tick += (s, ev) =>
                                    {
                                        if (targetBlock.MouseDragging)
                                        {
                                            secondsDragged += updateRate / 1000.0f;
                                            float multiplier = Math.Max(1.0f, secondsDragged / 2.0f);
                                            targetBlock.Weight += (float)(5.0f / (1000.0f / updateRate) * Math.Pow(multiplier, 3));
                                            WeightChanged.Invoke(targetBlock.Weight);
                                        }
                                        else
                                            secondsDragged = 0.0f;
                                    };
                                    bool accumulatorOn = false;
                                    b.MouseClick += (s, ev) =>
                                    {
                                        accumulatorOn = !accumulatorOn;
                                        if (accumulatorOn)
                                        {
                                            timer.Start();
                                            b.ForeColor = Color.LightSeaGreen;
                                        }
                                        else
                                        {
                                            timer.Stop();
                                            b.ForeColor = Color.Gold;
                                        }
                                    };

                                    break;
                                case 5:

                                    break;
                                case 6:

                                    break;
                                case 7:

                                    break;
                                case 8:

                                    break;
                                case 9:

                                    break;
                                case 10:

                                    break;
                            }
                            break;
                        case 2:
                            switch (x)
                            {
                                case 0:
                                    b.Name = "logWeight";
                                    b.Font = new Font(b.Font.FontFamily, 8f);
                                    b.ForeColor = Color.DeepPink;
                                    b.Text = "ln";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        if (targetBlock.Weight > 0)
                                        {
                                            targetBlock.Weight = (float)Math.Log(targetBlock.Weight);
                                            WeightChanged.Invoke(targetBlock.Weight);
                                        }
                                    };
                                    break;
                                case 1:
                                    b.Name = "naturalLogWeight";
                                    b.Font = new Font(b.Font.FontFamily, 8f);
                                    b.ForeColor = Color.DarkTurquoise;
                                    b.Text = "log";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        if (targetBlock.Weight > 0)
                                        {
                                            targetBlock.Weight = (float)Math.Log10(targetBlock.Weight);
                                            WeightChanged.Invoke(targetBlock.Weight);
                                        }
                                    };
                                    break;
                                case 2:
                                    b.Name = "eulerWeight";
                                    b.Font = new Font(b.Font.FontFamily, 16f);
                                    b.ForeColor = Color.LightYellow;
                                    b.Text = "e";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        targetBlock.Weight = (float)Math.E;
                                        WeightChanged.Invoke(targetBlock.Weight);
                                    };
                                    break;
                                case 3:
                                    b.Name = "sumDigitsOfWeight";
                                    b.Font = new Font(b.Font.FontFamily, 16f);
                                    b.ForeColor = Color.ForestGreen;
                                    b.Text = "Σ";
                                    b.MouseClick += (s, ev) =>
                                    {
                                        string blockWeight = Math.Abs(targetBlock.Weight).ToString();
                                        float sum = 0f;
                                        foreach (var ch in blockWeight)
                                            sum += (float)char.GetNumericValue(ch);
                                        targetBlock.Weight = QOL.ValidFloat32(sum) ? sum : targetBlock.Weight;
                                        WeightChanged.Invoke(targetBlock.Weight);
                                    };
                                    break;
                                case 4:

                                    break;
                                case 5:

                                    break;
                                case 6:

                                    break;
                                case 7:

                                    break;
                                case 8:

                                    break;
                                case 9:

                                    break;
                                case 10:

                                    break;
                            }
                            break;
                    }
                    Controls.Add(b);
                }
            }
        }
    }
}
using System.Drawing;
using System.Windows.Forms;

namespace Dropper
{
    public class Floor : CustomPanel
    {
        private const string Title = "Dropper";
        private readonly float TitleFontSize = 26f;
        private Font TitleFont => new Font(QOL.VCROSDMONO, TitleFontSize);
        private Rectangle TitleRect => new Rectangle(new Point(5, 0), TextRenderer.MeasureText(Title, new Font(QOL.VCROSDMONO, TitleFontSize + 2f)));
        public Color TitleColor { get; set; } = QOL.RandomColor();
        public Color ShadowTitleColor { get; set; } = QOL.RandomColor();
        public Color BorderColor => TitleColor;

        public Floor()
        {
            BackColor = QOL.RGB(40);

            Paint += (s, ev) =>
            {
                Graphics g = ev.Graphics;

                using (var mainBrush = new SolidBrush(ShadowTitleColor))
                    g.DrawString(Title, TitleFont, mainBrush, TitleRect);
                using (var shadowBrush = new SolidBrush(TitleColor))
                    g.DrawString(Title, TitleFont, shadowBrush, new Rectangle(new Point(TitleRect.X - 1, TitleRect.Y - 1), TitleRect.Size));
            };

            MouseDown += (s, ev) =>
            {
                if (ev.Button == MouseButtons.Right)
                {
                    TitleColor = QOL.RandomColor();
                    ShadowTitleColor = QOL.RandomColor();
                    Invalidate();
                }
            };
        }
    }
}
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Media;
using System.Windows.Forms;

namespace Dropper
{
    public class GameArea : CustomPanel
    {
        public event Action<Block> FocusedBlockChanged;
        public event Action<Block> SplitBlock;
        private bool debug = false;

        public GameArea()
        {
            BackColor = QOL.RGB(20);
            Paint += (s, ev) =>
            {
                var g = ev.Graphics;
                g.SmoothingMode = SmoothingMode.AntiAlias;

                DrawInactiveBlocks(g);
                DrawActiveBlocks(g);
            };
            Clicks();
        }

        private void DrawInactiveBlocks(Graphics g)
        {
            foreach (var block in Blocks.Stack)
            {
                if (block.Active) continue;

                using (var blockBrush = new SolidBrush(block.InactiveColor))
                    g.FillRectangle(
                        blockBrush,
                        block.Bounds.X,
                        block.Bounds.Y,
                        block.Bounds.Width,
                        block.Bounds.Height);

                Crack.DrawAll(g, block);

                using (var borderPen = new Pen(block.InactiveBorderColor, (float)block.BorderWidth))
                    g.DrawRectangle(
                        borderPen,
                        block.Bounds.X,
                        block.Bounds.Y,
                        block.Bounds.Width,
                        block.Bounds.Height);

                if (debug)
                    using (var brush = new SolidBrush(Color.IndianRed))
                    {
                        var font = new Font(QOL.VCROSDMONO, 20f);
                        var size = TextRenderer.MeasureText(block.Weight.ToString(), font);
                        g.DrawString(
                            $"{block.Weight:F0}",
                            new Font(QOL.VCROSDMONO, 16f),
                            brush,
                            new PointF(
                                block.Left + size.Width / 8,
                                block.Top + size.Height / 2));
                    }
            }

        }
        private void DrawActiveBlocks(Graphics g)
        {
            foreach (var block in Blocks.Stack)
            {
                if (!block.Active) continue;

                using (var blockBrush = new SolidBrush(block.ActiveColor))
                    g.FillRectangle(
                        blockBrush,
                        block.Bounds.X,
                        block.Bounds.Y,
                        block.Bounds.Width,
                        block.Bounds.Height);

                Crack.DrawAll(g, block);

                using (var borderPen = new Pen(block.ActiveBorderColor, (float)block.BorderWidth))
                    g.DrawRectangle(
                        borderPen,
                        block.Bounds.X,
                        block.Bounds.Y,
                        block.Bounds.Width,
                        block.Bounds.Height);

                if (debug)
                    using (var brush = new SolidBrush(Color.IndianRed))
                    {
                        var font = new Font(QOL.VCROSDMONO, 20f);
                        var size = TextRenderer.MeasureText(block.Weight.ToString(), font);
                        g.DrawString(
                            $"{block.Weight:F0}",
                            new Font(QOL.VCROSDMONO, 16f),
                            brush,
                            new PointF(
                                block.Left + size.Width / 8,
                                block.Top + size.Height / 2));
                    }
            }

        }

        private void Clicks()
        {
            Block draggable = null;
            PointF dragOffset = PointF.Empty;

            MouseDown += (s, ev) =>
                {
                    Block clicked = null;
                    for (int i = 0; i < Blocks.Stack.Count; i++)
                    {
                        if (Blocks.Stack[i].Bounds.Contains(ev.Location))
                        {
                            clicked = Blocks.Stack[i];
                            break;
                        }
                    }

                    if (ev.Button == MouseButtons.Left)
                    {
                        if (clicked != null)
                        {
                            FocusedBlockChanged.Invoke(clicked);
                            draggable = clicked;
                            draggable.MouseDragging = true;
                            draggable.ResetVelocity();
                            dragOffset = new PointF(ev.Location.X - draggable.X, ev.Location.Y - draggable.Y);
                        }
                    }

                    if (ev.Button == MouseButtons.Right)
                    {
                        if (clicked != null)
                        {
                            if (clicked.Cracks.Count >= 2)
                            {
                                clicked.Cracks.Clear();
                                SplitBlock.Invoke(clicked);
                                var sp = new SoundPlayer(Properties.Resources.Hector);
                                sp.Play();
                            }
                            else
                                clicked.Cracks.Add(new Crack(clicked));
                        }
                    }
                };

            MouseUp += (s, ev) =>
            {
                if (ev.Button == MouseButtons.Left && draggable != null)
                {
                    draggable.MouseDragging = false;
                    draggable = null;
                }
            };

            MouseMove += (s, ev) =>
            {
                if (draggable == null) return;

                float dx = ev.X - dragOffset.X;
                float dy = ev.Y - dragOffset.Y;

                draggable.Bounds = new RectangleF(
                    new PointF(dx, dy),
                    draggable.Size);
                draggable.Constrain();

                Invalidate();
            };
        }
    }
}
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;

namespace Dropper
{
    public class Gravity
    {
        public int X { get; set; } = 0;
        public int Y { get; set; } = 1;

        public static readonly float GravitationalConstant = 16f;

        public Timer Timer { get; set; } = new Timer() { Interval = QOL.GlobalTimerUpdateRate };
        public event Action<Block> SplitBlock;
        public event Action<float> VXChanged;
        public event Action<float> VYChanged;

        public event Action Redraw;

        public void Apply(Block block)
        {
            switch (block.Gravity)
            {
                case Block.GravityMode.Linear:
                    LinearGravity(block);
                    break;
                case Block.GravityMode.Dynamic:
                    DynamicGravity(block);
                    break;
                case Block.GravityMode.Magnetic:
                    MagneticGravity(block);
                    break;
            }
        }

        private void LinearGravity(Block block)
        {
            block.Bounds = new RectangleF(
                new PointF(
                    block.X + block.Weight * X,
                    block.Y + block.Weight * Y),
                block.Size);
        }

        private void DynamicGravity(Block block)
        {
            float deltaTime = QOL.GlobalTimerUpdateRate / 1000f;

            block.VX += block.Weight * deltaTime * GravitationalConstant * X;
            block.VY += block.Weight * deltaTime * GravitationalConstant * Y;

            if (block.Weight * X > 0)
                block.VX = Math.Min(block.VX, block.TerminalVelocity);
            if (block.Weight * Y > 0)
                block.VY = Math.Min(block.VY, block.TerminalVelocity);

            if (block.Weight * X < 0)
                block.VX = Math.Max(block.VX, -block.TerminalVelocity);
            if (block.Weight * Y < 0)
                block.VY = Math.Max(block.VY, -block.TerminalVelocity);

            block.Bounds = new RectangleF(
                new PointF(
                    block.X + block.VX * deltaTime,
                    block.Y + block.VY * deltaTime),
                block.Size);
        }

        private void MagneticGravity(Block block)
        {
            float stepX = 0f;
            float stepY = 0f;
            if (block.X != block.MagneticCore.X)
            {
                float dx = block.MagneticCore.X - block.X;
                stepX = Math.Min(Math.Abs(dx), block.Weight) * Math.Sign(dx);
            }
            if (block.Y != block.MagneticCore.Y)
            {
                float dy = block.MagneticCore.Y - block.Y;
                stepY = Math.Min(Math.Abs(dy), block.Weight) * Math.Sign(dy);
            }

            block.Bounds = new RectangleF(
                new PointF(
                    block.X + stepX,
                    block.Y + stepY),
                block.Size);
        }

        public void Start(List<Block> blocks)
        {
            var blocksToSplit = new List<Block>();
            Timer.Tick += (s, ev) =>
            {
                if (blocks == null || blocks.Count == 0) return;

                foreach(var block in blocks)
                {
                    if (!block.MouseDragging) //&& block.Active
                    {
                        Apply(block);
                        block.Constrain(X, Y);
                    }
                    if (block.Cracks.Count == 3)
                        blocksToSplit.Add(block);
                }
                foreach (var block in blocksToSplit)
                    SplitBlock.Invoke(block);
                blocksToSplit.Clear();

                Block active = blocks.Find(x => x.Active);
                if (active != null && active.Gravity == Block.GravityMode.Dynamic)
                {
                    VXChanged?.Invoke(active.VX);
                    VYChanged?.Invoke(active.VY);
                }
                else
                {
                    VXChanged?.Invoke(0f);
                    VYChanged?.Invoke(0f);
                }
                Redraw.Invoke();
            };
            Timer.Start();
        }
    }
}
using System;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;

namespace Dropper
{
    public class GravityPanel : CustomPanel
    {
        public Label displayVX, displayVY;
        //public Label displayVTX, displayVTY;
        //private Action GravityModeUpdated;

        private bool built;
        private Block targetBlock;

        public void SetTarget(Block block)
        {
            targetBlock = block ?? throw new ArgumentNullException();
            if (!built)
            {
                Build();
                built = true;
            }

            //block.VTXChanged += newVTX => displayVTX.Text = $"{block.VTX:F1}";
            //block.VTYChanged += newVTY => displayVTY.Text = $"{block.VTY:F1}";
        }

        private void Build()
        {
            ForeColor = Color.White;
            BackColor = Color.Transparent;
            Paint += (s, ev) =>
            {
                using (var pen = new Pen(BackColor, 1f))
                    ev.Graphics.DrawRectangle(pen, 0, 0, Width - 1, Height - 1);
            };

            var gravityModes = Enum.GetValues(typeof(Block.GravityMode)).Cast<object>().ToArray();

            int gravityModeIndex = Array.IndexOf(gravityModes, Block.GravityMode.Dynamic);
            targetBlock.Gravity = (Block.GravityMode)gravityModes[gravityModeIndex];
            var gravityChoice = new CustomButton()
            {
                UseCompatibleTextRendering = true,
                TabStop = false,
                FlatStyle = FlatStyle.Flat,
                Font = new Font(QOL.VCROSDMONO, 20f),
                BackColor = QOL.RGB(20),
                Text = gravityModes[gravityModeIndex].ToString(),
                AutoSize = true,
            };
            gravityChoice.MouseClick += (s, ev) =>
            {
                if (ev.Button == MouseButtons.Left)
                {
                    gravityModeIndex++;
                    if (gravityModeIndex == gravityModes.Length)
                        gravityModeIndex = 0;

                    targetBlock.Gravity = (Block.GravityMode)gravityModes[gravityModeIndex];
                    gravityChoice.Text = gravityModes[gravityModeIndex].ToString();
                    //GravityModeUpdated.Invoke();
                }
            };
            Controls.Add(gravityChoice);

            displayVX = new Label()
            {
                ForeColor = Color.White,
                Font = new Font(QOL.VCROSDMONO, 16f)
            };
            QOL.Align.Bottom.Center(displayVX, gravityChoice, 1);
            Controls.Add(displayVX);

            displayVY = new Label()
            {
                ForeColor = Color.White,
                Font = new Font(QOL.VCROSDMONO, 16f),
                AutoSize = true,
            };
            QOL.Align.Bottom.Center(displayVY, displayVX, 1);
            Controls.Add(displayVY);

            //displayVTX = new Label()
            //{
            //    ForeColor = Color.White,
            //    Font = new Font(QOL.VCROSDMONO, 16f)
            //};
            //QOL.Align.Right(displayVTX, displayVX, 16);
            //Controls.Add(displayVTX);

            //displayVTY = new Label()
            //{
            //    ForeColor = Color.White,
            //    Font = new Font(QOL.VCROSDMONO, 16f),
            //    AutoSize = true,
            //};
            //QOL.Align.Bottom.Center(displayVTY, displayVTX, 1);
            //Controls.Add(displayVTY);
        }
    }
}
using System;
using System.Drawing;
using System.Windows.Forms;

namespace Dropper
{
    public class LerpButton : Button
    {
        public bool On { get; set; }

        public Color BaseColor { get; set; } = QOL.RGB(35);
        private readonly Color HoverColor = QOL.RGB(60);
        private readonly Color BorderHoverColor = QOL.RGB(80);
        public Color? ClickColor { get; set; }
        private bool ShowBorder = false;
        private Color CurrentColor;

        private Color TargetColor;
        private readonly Timer AnimationTimer = new Timer() { Interval = 10 };
        private float AnimationProgress;
        private float AnimationSpeed { get; set; } = 0.0175f;

        public LerpButton(float? animationSpeed = null, Color? clickColor = null)
        {
            ClickColor = clickColor;
            AnimationSpeed = animationSpeed ?? AnimationSpeed;

            DoubleBuffered = true;
            TabStop = false;
            FlatAppearance.BorderSize = 0;
            FlatStyle = FlatStyle.Flat;
            TextAlign = ContentAlignment.MiddleCenter;
            ForeColor = Color.White;

            CurrentColor = TargetColor = BaseColor;
            AnimationTimer.Tick += AnimateColor;
        }
        protected override bool ShowFocusCues => false;
        protected override bool ShowKeyboardCues => false;

        protected override void OnPaint(PaintEventArgs e)
        {
            var g = e.Graphics;

            g.Clear(CurrentColor);
            TextRenderer.DrawText(
                g,
                Text,
                Font,
                ClientRectangle,
                ForeColor,
                TextFormatFlags.HorizontalCenter
                | TextFormatFlags.VerticalCenter);

            if (ShowBorder)
                using (var borderPen = new Pen(BorderHoverColor, 2f))
                    g.DrawRectangle(borderPen, ClientRectangle.X, ClientRectangle.Y, ClientSize.Width - 1, ClientSize.Height - 1);
        }

        private Color LerpColor(Color from, Color to, float t)
        {
            int r = (int)(from.R + (to.R - from.R) * t);
            int g = (int)(from.G + (to.G - from.G) * t);
            int b = (int)(from.B + (to.B - from.B) * t);
            return Color.FromArgb(255, r, g, b);
        }

        private void StartAnimation(Color @new)
        {
            TargetColor = @new;
            AnimationProgress = 0f;
            AnimationTimer.Start();
        }

        private void AnimateColor(object sender, EventArgs e)
        {
            AnimationProgress += AnimationSpeed;
            if (AnimationProgress >= 1f)
            {
                AnimationProgress = 1f;
                AnimationTimer.Stop();
            }
            CurrentColor = LerpColor(CurrentColor, TargetColor, AnimationProgress);
            Invalidate();
        }

        protected override void OnMouseEnter(EventArgs e)
        {
            base.OnMouseEnter(e);
            StartAnimation(HoverColor);
            ShowBorder = true;
        }

        protected override void OnMouseLeave(EventArgs e)
        {
            base.OnMouseLeave(e);
            StartAnimation(BaseColor);
            ShowBorder = false;
        }

        protected override void OnMouseDown(MouseEventArgs e)
        {
            base.OnMouseDown(e);
            if (ClickColor is Color clickColor)
                StartAnimation(clickColor);
        }

        protected override void OnMouseUp(MouseEventArgs e)
        {
            base.OnMouseUp(e);
            StartAnimation(HoverColor);
        }
    }
}
using System;
using System.Drawing;
using System.Windows.Forms;

namespace Dropper
{
    public class PivotPanel : CustomPanel
    {
        private readonly Random random = new Random();

        private readonly Gravity Gravity;

        private bool built;
        private Block targetBlock;

        public PivotPanel(Gravity gravity) => Gravity = gravity;

        public void SetTarget(Block block)
        {
            targetBlock = block ?? throw new ArgumentNullException();
            if (!built)
            {
                Build();
                built = true;
            }
            // flip cards according to new current target block's pivots
        }

        private void Build()
        {
            ForeColor = Color.White;
            BackColor = Color.Transparent;
            Paint += (s, ev) =>
            {
                using (var pen = new Pen(BackColor, 1f))
                    ev.Graphics.DrawRectangle(pen, 0, 0, Width - 1, Height - 1);
            };

            var pivots = new CustomPanel
            {
                BackColor = QOL.RGB(60),
                Width = Card.CardWidth * 3,
                Height = Card.CardHeight * 3,
            };
            Controls.Add(pivots);

            string[,] directions =
            {
                { "↖", "↑", "↗" },
                { "←", "◎", "→" },
                { "↙", "↓", "↘" }
            };

            var cards = new Card[3, 3];
            int[] offsets = { -1, 0, 1 };

            for (int row = 0; row < cards.GetLength(0); row++)
            {
                for (int col = 0; col < cards.GetLength(1); col++)
                {
                    int r = row;
                    int c = col;

                    cards[r, c] = new Card(r, c)
                    {
                        Location = new Point(c * Card.CardWidth, r * Card.CardHeight),
                        Text = directions[r, c]
                    };
                    pivots.Controls.Add(cards[r, c]);

                    if (r == 2 && c == 1)
                        cards[r, c].Toggle();
                }
            }
            Card.deck = cards;

            var dissipateVX = new Timer() { Interval = 100 };
            dissipateVX.Tick += (s, ev) =>
            {
                if (Math.Abs(targetBlock.VX) <= 0.1)
                {
                    dissipateVX.Stop();
                    targetBlock.VX = 0;
                }
                targetBlock.VX -= targetBlock.VX / 10;
            };
            var dissipateVY = new Timer() { Interval = 100 };
            dissipateVY.Tick += (s, ev) =>
            {
                if (Math.Abs(targetBlock.VY) <= 0.1)
                {
                    dissipateVY.Stop();
                    targetBlock.VY = 0;
                }
                targetBlock.VY -= targetBlock.VY / 10;
            };
            Card.Activated = (row, col) =>
            {
                int nx = offsets[col];
                int ny = offsets[row];

                if (nx != Gravity.X || ny != Gravity.Y)
                {
                    Gravity.X = nx;
                    Gravity.Y = ny;

                    if (nx != 0)
                        dissipateVX.Stop();
                    else
                        dissipateVX.Start();

                    if (ny != 0)
                        dissipateVY.Stop();
                    else
                        dissipateVY.Start();
                }
            };

            Button[] buttons = new CustomButton[Height / Card.CardHeight];
            for (int i = 0; i < buttons.Length; i++)
            {
                int x = i;
                buttons[x] = QOL.GenericControls.Button(16f, null, Color.Gray, new Size(Card.CardWidth, Card.CardHeight));
                buttons[x].Location = new Point(pivots.Right + 1, i * Card.CardHeight);

                switch (x)
                {
                    case 0:
                        buttons[x].Name = "RandomPivot";
                        buttons[x].UseCompatibleTextRendering = false;
                        buttons[x].TextAlign = ContentAlignment.TopCenter;
                        buttons[x].Text = "🎲";
                        buttons[x].ForeColor = Color.Green;
                        var randomPivotTimer = new Timer() { Interval = 1001 };
                        randomPivotTimer.Tick += (s, ev) => cards[random.Next(cards.GetLength(0)), random.Next(cards.GetLength(1))].SetActive();

                        bool randomPivotOn = false;
                        Card copyActiveCard = null;
                        var copyColor = buttons[x].ForeColor;
                        buttons[x].MouseDown += (s, ev) =>
                        {
                            if (ev.Button == MouseButtons.Left)
                            {
                                randomPivotOn = !randomPivotOn;
                                if (randomPivotOn)
                                {
                                    copyActiveCard = Card.GetActive();
                                    randomPivotTimer.Start();
                                    buttons[x].ForeColor = Color.FromArgb(255, 42, 96, 163);
                                }
                                else
                                {
                                    randomPivotTimer.Stop();
                                    randomPivotTimer.Interval = 1001;

                                    copyActiveCard?.SetActive();
                                    buttons[x].ForeColor = copyColor;
                                }
                            }
                            if (ev.Button == MouseButtons.Right && randomPivotTimer.Interval > 1)
                                randomPivotTimer.Interval -= 100;
                        };
                        break;
                    case 1:

                        break;
                    case 2:

                        break;
                }
                Controls.Add(buttons[x]);
            }
        }
    }
}
using System;
using System.Diagnostics;
using System.Windows.Forms;

namespace Dropper
{
    internal static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            string currentName = Process.GetCurrentProcess().ProcessName;
            foreach (var process in Process.GetProcessesByName(currentName))
            {
                if (process.Id != Process.GetCurrentProcess().Id)
                    process.Kill();
            }
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}
using System;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;

namespace Dropper
{
    public static class QOL
    {
        private static readonly Random random = new Random();
        public static readonly string VCROSDMONO = "VCR OSD Mono";
        public const int GlobalTimerUpdateRate = 10;

        public static int RandomInt(int max, int? min = null) => random.Next(min ?? 0, max);

        public static Color RandomColor() => Color.FromArgb(255, RandomInt(256), RandomInt(256), RandomInt(256));
        public static Color RGB(int v1, int? v2 = null, int? v3 = null) => Color.FromArgb(255, v1, v2 ?? v1, v3 ?? v1);

        public static void WriteOut(object o) => MessageBox.Show($"{o}");
        public static void QuickWriteOut(Func<object> getter, Control surface)
        {
            surface.MouseClick += (s, ev) =>
            {
                if (ev.Button == MouseButtons.Right)
                    WriteOut(getter());
            };
        }

        public static void ClampControlWidth(Control control, int? gap = null)
        {
            if (control.Controls.Count == 0) return;
            int rightMost = control.Controls.Cast<Control>().Max(x => x.Right);
            control.Bounds = new Rectangle(control.Location, new Size(rightMost + (gap ?? 0), control.Height));
        }
        public static void ClampControlHeight(Control control, int? gap = null)
        {
            if (control.Controls.Count == 0) return;
            int bottomMost = control.Controls.Cast<Control>().Max(x => x.Bottom);
            control.Bounds = new Rectangle(control.Location, new Size(control.Width, bottomMost + (gap ?? 0)));
        }
        public static void ClampControlSize(Control control, int? widthGap = null, int? heightGap = null)
        {
            if (control.Controls.Count == 0) return;
            int rightMost = control.Controls.Cast<Control>().Max(x => x.Right);
            int bottomMost = control.Controls.Cast<Control>().Max(x => x.Bottom);
            control.Bounds = new Rectangle(control.Location, new Size(rightMost + (widthGap ?? 0), bottomMost + (heightGap ?? 0)));
        }

        public static bool ValidInt32(int num) => num > int.MinValue && num < int.MaxValue;
        public static bool ValidFloat32(float num) => !float.IsNaN(num) && !float.IsInfinity(num);
        public static bool ValidDouble64(float num) => num > double.MinValue && num < double.MaxValue;

        public static int Factorial(int num)
        {
            if (num == 0 || num == 1) return 1;
            return num *= Factorial(num - 1);
        }

        public static class Align
        {
            private static int CheckGap(int? gap) => gap ?? 0;

            public static void Left(Control thisControl, Control otherControl, int? gap = null, bool? top = null)
            {
                int multiplier = top == false ? 1 : 0;
                thisControl.Location = new Point(
                    otherControl.Location.X - otherControl.Width - CheckGap(gap),
                    otherControl.Location.Y + multiplier * (otherControl.Height - thisControl.Height));
            }

            public static void Right(Control thisControl, Control otherControl, int? gap = null, bool? top = null)
            {
                int multiplier = top == false ? 1 : 0;
                thisControl.Location = new Point(
                    otherControl.Location.X + otherControl.Width + CheckGap(gap),
                    otherControl.Location.Y + multiplier * (otherControl.Height - thisControl.Height));
            }

            public static class Top
            {
                public static void Left(Control thisControl, Control otherControl, int? gap = null) =>
                    thisControl.Location = new Point(
                        otherControl.Location.X - thisControl.Width,
                        otherControl.Location.Y - thisControl.Height - CheckGap(gap));

                public static void Center(Control thisControl, Control otherControl, int? gap = null) =>
                    thisControl.Location = new Point(
                        otherControl.Location.X + otherControl.Width / 2 - thisControl.Width / 2,
                        otherControl.Location.Y - thisControl.Height - CheckGap(gap));

                public static void LeftCenter(Control thisControl, Control otherControl, int? gap = null) =>
                    thisControl.Location = new Point(
                        otherControl.Location.X - thisControl.Width / 2,
                        otherControl.Location.Y - thisControl.Height - CheckGap(gap));

                public static void RightCenter(Control thisControl, Control otherControl, int? gap = null) =>
                    thisControl.Location = new Point(
                        otherControl.Location.X + otherControl.Width - thisControl.Width / 2,
                        otherControl.Location.Y - thisControl.Height - CheckGap(gap));

                public static void Right(Control thisControl, Control otherControl, int? gap = null) =>
                    thisControl.Location = new Point(
                        otherControl.Location.X + otherControl.Width,
                        otherControl.Location.Y - thisControl.Height - CheckGap(gap));
            }

            public static class Bottom
            {
                public static void Left(Control thisControl, Control otherControl, int? gap = null) =>
                    thisControl.Location = new Point(
                        otherControl.Location.X,
                        otherControl.Location.Y + otherControl.Height + CheckGap(gap));

                public static void Center(Control thisControl, Control otherControl, int? gap = null) =>
                    thisControl.Location = new Point(
                        otherControl.Location.X,
                        otherControl.Location.Y + otherControl.Height + CheckGap(gap));

                public static void LeftCenter(Control thisControl, Control otherControl, int? gap = null) =>
                    thisControl.Location = new Point(
                        otherControl.Location.X - thisControl.Width / 2,
                        otherControl.Location.Y + otherControl.Height + CheckGap(gap));

                public static void RightCenter(Control thisControl, Control otherControl, int? gap = null) =>
                    thisControl.Location = new Point(
                        otherControl.Location.X + otherControl.Width - thisControl.Width / 2,
                        otherControl.Location.Y + otherControl.Height + CheckGap(gap));

                public static void Right(Control thisControl, Control otherControl, int? gap = null) =>
                    thisControl.Location = new Point(
                        otherControl.Location.X + otherControl.Width,
                        otherControl.Location.Y + otherControl.Height + CheckGap(gap));
            }
        }

        public static class GenericControls
        {
            public static CustomButton Button(float? fontSize = null, string text = null, Color? forecolor = null, Size? size = null)
            {
                return new CustomButton()
                {
                    UseCompatibleTextRendering = true,
                    TabStop = false,
                    FlatStyle = FlatStyle.Flat,
                    TextAlign = ContentAlignment.MiddleCenter,
                    BackColor = RGB(20),
                    Size = size ?? new Size(24, 24),
                    Font = new Font(VCROSDMONO, fontSize ?? 20f, FontStyle.Regular),
                    ForeColor = forecolor ?? Color.White,
                    Text = text ?? string.Empty,
                };
            }
        }

        public static class Obscure
        {
            public static CustomPanel DrawOverTrackBarRail(TrackBar bar)
            {
                return new CustomPanel()
                {
                    Location = new Point(bar.Bounds.X + 8, bar.Bounds.Y + 8),
                    Size = new Size(bar.Width - 16, 4),
                    BackColor = Color.RoyalBlue,
                };
            }
        }
    }
}
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;

namespace Dropper
{
    public class ToolBarPanel : CustomPanel
    {
        private readonly Gravity Gravity;

        public WeightPanel weightPanel;
        public WeightSlider weightSlider;
        public ExpandedWeightMenu expandedWeightMenu;
        public PivotPanel pivotPanel;
        public GravityPanel gravityPanel;

        public List<CustomPanel> Values = new List<CustomPanel>();

        private bool built = false;
        private Block targetBlock;

        public void SetTarget(Block block)
        {
            targetBlock = block ?? throw new ArgumentNullException();

            weightPanel.SetTarget(targetBlock);
            weightSlider.SetTarget(targetBlock);
            expandedWeightMenu.SetTarget(targetBlock);
            pivotPanel.SetTarget(targetBlock);
            gravityPanel.SetTarget(targetBlock);

            Gravity.VXChanged += newVX =>
            {
                if (block.Gravity == Block.GravityMode.Dynamic)
                    gravityPanel.displayVX.Text = $"{newVX:F1}";
            };
            Gravity.VYChanged += newVY =>
            {
                if (block.Gravity == Block.GravityMode.Dynamic)
                    gravityPanel.displayVY.Text = $"{newVY:F1}";
            };

            Gravity.Redraw += () =>
            {
                if (block.Gravity != Block.GravityMode.Dynamic)
                {
                    gravityPanel.displayVX.Text = "";
                    gravityPanel.displayVY.Text = "";
                }
            };
        }

        public ToolBarPanel(Gravity gravity)
        {
            Gravity = gravity;
            BackColor = QOL.RGB(50);

            weightPanel = new WeightPanel();
            weightSlider = new WeightSlider();
            expandedWeightMenu = new ExpandedWeightMenu();
            pivotPanel = new PivotPanel(gravity);
            gravityPanel = new GravityPanel();

            Values.AddRange(new CustomPanel[] { weightPanel, weightSlider, expandedWeightMenu, pivotPanel, gravityPanel });

            foreach (var value in Values)
                Controls.Add(value);

            if (!built)
                Build();
        }

        private void InitializeLayout()
        {
            foreach (var value in Values)
            {
                value.Draggable = true;
                value.ParentBounds = ClientRectangle;

                if (value == weightSlider || value == pivotPanel) continue;
                QOL.ClampControlSize(value);
            }

            if (!weightPanel.Added)
            {
                weightPanel.Location = new Point(0, 0);
                weightPanel.Added = true;
            }

            weightSlider.Width = 144;
            if (!weightSlider.Added)
            {
                QOL.Align.Bottom.Center(weightSlider, weightPanel, 8);
                weightSlider.Added = true;
            }

            if (!expandedWeightMenu.Added)
            {
                QOL.Align.Bottom.Center(expandedWeightMenu, weightPanel, 2);
                expandedWeightMenu.Added = true;
            }

            if (!pivotPanel.Added)
            {
                pivotPanel.Location = new Point(weightPanel.Right + 16, 2);
                pivotPanel.Added = true;
            }

            if (!gravityPanel.Added)
            {
                QOL.Align.Right(gravityPanel, pivotPanel, 16);
                gravityPanel.Added = true;
            }
        }

        private bool LayoutInitialized = false;
        protected override void OnLayout(LayoutEventArgs e)
        {
            base.OnLayout(e);
            if (!LayoutInitialized)
            {
                InitializeLayout();
                LayoutInitialized = true;
            }
        }
        public void Build()
        {
            built = true;

            weightPanel.CollapseExpandedWeightPanel += (s, ev) =>
            {
                expandedWeightMenu.Visible = !expandedWeightMenu.Visible;
                weightPanel.collapsableMenu.Text = expandedWeightMenu.Visible ? "-" : "+";
            };

            void OnWeightChanged(float newWeight)
            {
                if (QOL.ValidFloat32(newWeight))
                {
                    if (newWeight > 0)
                        targetBlock.Weight = Math.Min(newWeight, 100000);
                    if (newWeight < 0)
                        targetBlock.Weight = Math.Max(newWeight, -100000);
                }
                else
                    targetBlock.Weight = targetBlock.OriginalWeight;

                if (targetBlock.Weight > -100 && targetBlock.Weight < 100)
                    weightPanel.weightDisplay.Text = $"{newWeight:F1}";
                else
                    weightPanel.weightDisplay.Text = $"{newWeight:F0}";
            }

            weightSlider.WeightChanged += OnWeightChanged;

            expandedWeightMenu.BringToFront();
            expandedWeightMenu.MouseClick += (s, ev) => weightSlider.Visible = false;
            expandedWeightMenu.WeightChanged += OnWeightChanged;
        }
        public new void Hide()
        {
            Visible = false;
            Values.ForEach(x => x.Visible = false);
        }
    }
}
using System;
using System.Drawing;
using System.Windows.Forms;

namespace Dropper
{
    public class TrackBarOverlayed : TrackBar
    {
        //Constant for windows "paint" message
        private const int WM_PAINT = 0x0F;
        public Color RailCover { get; set; } = Color.RoyalBlue;

        public TrackBarOverlayed()
        {
            DoubleBuffered = true;
            TabStop = false;
        }

        protected override void WndProc(ref Message m)
        {
            base.WndProc(ref m);

            if (m.Msg == WM_PAINT)
            {
                using (var g = CreateGraphics())
                {
                    var cover = new Rectangle(new Point(8, 8), new Size(ClientSize.Width - 16, 4));
                    using (var brush = new SolidBrush(RailCover))
                        g.FillRectangle(brush, cover);
                }
            }
        }

        protected override void OnKeyDown(KeyEventArgs e)
        {
            e.Handled = true;
            if (e.KeyCode == Keys.Left && Value != Minimum) Value--;
            if (e.KeyCode == Keys.Right && Value != Maximum) Value++;
        }

        protected override bool ShowFocusCues => false;
        protected override bool ShowKeyboardCues => false;

        protected override void OnGotFocus(EventArgs e)
        {
            base.OnGotFocus(e);
            Parent?.Focus();
        }
    }
}
using System;
using System.Drawing;
using System.Windows.Forms;

namespace Dropper
{
    public class WeightPanel : CustomPanel
    {
        public ClickFilter WeightDisplayFilter;

        public TextBox weightDisplay;

        public Button collapsableMenu;
        public event EventHandler CollapseExpandedWeightPanel;

        private bool built;
        private Block targetBlock;

        public void SetTarget(Block block)
        {
            targetBlock = block ?? throw new ArgumentNullException();
            if (!built)
            {
                Build();
                built = true;
            }
            else
                UpdateWeightDisplay();
        }

        public void UpdateWeightDisplay()
        {
            if (targetBlock.Weight > -100 && targetBlock.Weight < 100)
                weightDisplay.Text = $"{targetBlock.Weight:F1}";
            else
                weightDisplay.Text = $"{targetBlock.Weight:F0}";
        }

        private void Build()
        {
            ForeColor = Color.Transparent;
            BackColor = QOL.RGB(35);
            Width = 264;
            Height = 24;
            Paint += (s, ev) =>
            {
                using (var pen = new Pen(BackColor, 1f))
                    ev.Graphics.DrawRectangle(pen, 0, 0, Width - 1, Height - 1);
            };

            weightDisplay = new TextBox()
            {
                Anchor = AnchorStyles.Left,
                TabStop = false,
                BorderStyle = BorderStyle.None,
                BackColor = QOL.RGB(100),
                ForeColor = Color.White,
                Font = new Font(QOL.VCROSDMONO, 17f),
                Text = $"{targetBlock.Weight:F1}",
                Width = 92,
            };
            weightDisplay.TextChanged += (s, ev) =>
            {
                if (float.TryParse(weightDisplay.Text, out float newWeight))
                {
                    if (newWeight > 0)
                        targetBlock.Weight = Math.Min(newWeight, 100000);
                    if (newWeight < 0)
                        targetBlock.Weight = Math.Max(newWeight, -100000);
                }
                else targetBlock.Weight = targetBlock.OriginalWeight;
                UpdateWeightDisplay();
            };
            weightDisplay.LostFocus += (s, ev) =>
            {
                if (string.IsNullOrEmpty(weightDisplay.Text)
                || !float.TryParse(weightDisplay.Text, out _))
                {
                    targetBlock.Weight = targetBlock.OriginalWeight;
                    UpdateWeightDisplay();
                }
            };
            Controls.Add(weightDisplay);
            WeightDisplayFilter = new ClickFilter(weightDisplay);
            Application.AddMessageFilter(WeightDisplayFilter);

            var resetWeight = QOL.GenericControls.Button(18f, "↻", Color.White);
            QOL.Align.Right(resetWeight, weightDisplay, 4);
            Controls.Add(resetWeight);
            resetWeight.MouseClick += (s, ev) =>
            {
                targetBlock.Weight = targetBlock.OriginalWeight;
                UpdateWeightDisplay();
            };

            collapsableMenu = QOL.GenericControls.Button(12f, "+", Color.White);
            QOL.Align.Right(collapsableMenu, resetWeight);
            Controls.Add(collapsableMenu);
            collapsableMenu.MouseClick += (s, ev) => CollapseExpandedWeightPanel.Invoke(this, EventArgs.Empty);
        }

        protected override void OnParentChanged(EventArgs e)
        {
            base.OnParentChanged(e);

            var form = FindForm();
            if (form != null)
            {
                form.FormClosing -= FormClosing;
                form.FormClosing += FormClosing;
            }
        }

        private void FormClosing(object sender, EventArgs e)
        {
            if (WeightDisplayFilter != null)
                Application.RemoveMessageFilter(WeightDisplayFilter);
        }
    }
}
using System;
using System.Drawing;
using System.Windows.Forms;

namespace Dropper
{
    public class WeightSlider : CustomPanel
    {
        public TrackBarOverlayed bar;

        public event Action<float> WeightChanged;

        private bool built;
        private Block targetBlock;

        public void SetTarget(Block block)
        {
            targetBlock = block ?? throw new ArgumentNullException();
            if (!built)
            {
                Build();
                built = true;
            }
        }

        private void Build()
        {
            BackColor = Color.Transparent;
            DoubleBuffered = true;

            bar = new TrackBarOverlayed
            {
                TabStop = false,
                BackColor = QOL.RGB(50),
                Size = new Size(ClientSize.Width, 20),
                TickStyle = TickStyle.None
            };
            Controls.Add(bar);

            bool positive = true;
            int[] barValues = { 0, 1, 2, 5, 10, 20, 35, 50, 100, 250, 500, 750, 1000, 10000, 100000 };
            bar.Maximum = barValues.Length - 1;
            bar.Value = 8;

            void UpdateBar()
            {
                if (positive)
                    targetBlock.Weight = barValues[bar.Value];
                else
                    targetBlock.Weight = -barValues[bar.Value];
                WeightChanged.Invoke(targetBlock.Weight);
            }

            var timer = new Timer() { Interval = 1000 };
            int seconds = 0;
            timer.Tick += (s, ev) =>
            {
                seconds++;
                if (seconds == 5)
                {
                    bar.RailCover = Color.RoyalBlue;
                    bar.Invalidate();
                    timer.Stop();
                }
            };

            bar.MouseDown += (s, ev) =>
            {
                if (ev.Button == MouseButtons.Right)
                {
                    timer.Stop();
                    seconds = 0;

                    positive = !positive;
                    bar.RailCover = positive ? Color.LimeGreen : Color.IndianRed;

                    UpdateBar();
                    bar.Invalidate();

                    timer.Start();
                }
            };
            bar.ValueChanged += (s, ev) => UpdateBar();
        }
    }
}
